# Graph 层 Checkpoint 与 Pregel 重启能力分析

## 问题

1. Graph 层 Checkpoint 是否保存了 Pregel 重启计算的所有信息？
2. Graph 层 Checkpoint 是否可以实现单个顶点任务重启？

## Graph 层 Checkpoint 保存的数据

代码位置：`beamai_agent_checkpoint.erl:163-170`

```erlang
StateData = #{
    messages => Msgs,           %% 对话消息
    full_messages => FullMsgs,  %% 完整消息历史
    scratchpad => Pad,          %% 中间步骤
    context => Ctx,             %% 用户上下文
    result => Result,           %% 执行结果
    metadata => #{...}          %% 元数据
}.
```

## 对比：Graph 层 vs Pregel 重启所需

```
┌─────────────────────────────────────────────────────────────────┐
│           Graph 层 Checkpoint vs Pregel 重启所需数据             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Graph 层保存的:                 Pregel 重启需要的:              │
│  ─────────────────              ──────────────────              │
│  ✅ messages                    ❌ superstep（当前超步）         │
│  ✅ full_messages               ❌ vertices（各顶点状态）        │
│  ✅ scratchpad                  ❌ inbox（待处理消息）           │
│  ✅ context                     ❌ pending_messages             │
│  ✅ result                      ❌ active_vertices              │
│  ✅ metadata                    ❌ 每个顶点的 halted 状态        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 问题 1：是否保存了 Pregel 重启计算的所有信息？

### 答案：❌ 没有

### 缺失的 Pregel 执行状态

```
┌─────────────────────────────────────────────────────────────────┐
│                    缺失的 Pregel 执行状态                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 超步信息                                                    │
│     ❌ superstep = 5  （执行到哪个超步）                         │
│                                                                 │
│  2. 顶点状态                                                    │
│     ❌ vertices = #{                                            │
│          __start__ => #{value => ..., halted => true},         │
│          llm_call => #{value => ..., halted => true},          │
│          execute_tools => #{value => ..., halted => false}     │
│        }                                                        │
│                                                                 │
│  3. 消息队列                                                    │
│     ❌ inbox = #{                                               │
│          execute_tools => [{state, S1}]                        │
│        }                                                        │
│                                                                 │
│  4. 待投递消息                                                   │
│     ❌ pending_messages = [{node_c, {state, S2}}]              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 当前 Checkpoint 能力

| 能力 | 支持 | 说明 |
|------|------|------|
| **恢复会话** | ✅ | 从 messages/context 恢复，重新开始执行 |
| **恢复到超步 N** | ❌ | 无超步信息 |
| **恢复顶点状态** | ❌ | 无各顶点的 vertex.value |
| **恢复待处理消息** | ❌ | 无 inbox 信息 |

### 恢复后会发生什么？

```
当前 Checkpoint 恢复流程:

┌─────────────────────────────────────────────────────────────────┐
│  原执行（中断前）:                                               │
│  超步 0 → 超步 1 → 超步 2 → [中断] → 超步 3 → ...              │
│                              ↑                                  │
│                           保存 checkpoint                        │
│                           (只有 messages, context)              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  恢复后:                                                         │
│  超步 0 → 超步 1 → 超步 2 → 超步 3 → ...                        │
│  ↑                                                              │
│  从头开始重新执行！                                               │
│  无法从超步 2 继续                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 问题 2：是否可以实现单个顶点任务重启？

### 答案：❌ 不能

### 单顶点重启需要的信息

```
┌─────────────────────────────────────────────────────────────────┐
│                单顶点重启需要的信息                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  要重启单个顶点，需要知道:                                        │
│                                                                 │
│  1. 哪个顶点失败了                                               │
│     ❌ Graph checkpoint 不保存顶点级别信息                       │
│                                                                 │
│  2. 该顶点收到的消息                                             │
│     ❌ inbox 没有保存                                            │
│                                                                 │
│  3. 其他顶点的状态（避免重复执行）                                │
│     ❌ vertices 状态没有保存                                     │
│                                                                 │
│  4. 该顶点的 vertex.value                                       │
│     ❌ 没有保存                                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 单顶点重启的两种场景

#### 场景 1: 超步内重试（内存中）

```
┌─────────────────────────────────────────────────────────────────┐
│  同一超步内，顶点 A 失败后立即重试                                │
│                                                                 │
│  需要的数据（都在 Worker 内存中）:                               │
│  ✅ 顶点的 vertex.value                                         │
│  ✅ 顶点收到的 messages                                         │
│  ✅ 其他顶点的已完成状态（superstep_state）                      │
│                                                                 │
│  Graph Checkpoint: ❌ 不涉及                                    │
│  实现方式: Worker 内 try-catch + superstep_state                │
└─────────────────────────────────────────────────────────────────┘
```

#### 场景 2: 跨进程/持久化恢复后重试

```
┌─────────────────────────────────────────────────────────────────┐
│  进程崩溃后，恢复并只重试失败的顶点                               │
│                                                                 │
│  需要的数据（必须持久化）:                                       │
│  ❌ superstep 编号                                              │
│  ❌ 所有顶点的 vertex.value                                     │
│  ❌ 失败顶点的 inbox                                            │
│  ❌ 已完成顶点的标记                                             │
│                                                                 │
│  Graph Checkpoint: ❌ 不支持                                    │
│  需要: Pregel 层 Checkpoint                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## 总结对比

| 功能 | Graph 层 Checkpoint | 需要 Pregel 层 Checkpoint |
|------|---------------------|--------------------------|
| **会话恢复** | ✅ 支持 | 不需要 |
| **历史查询** | ✅ 支持 | 不需要 |
| **超步级恢复** | ❌ 不支持 | ✅ 需要 |
| **单顶点重启（内存）** | ❌ 不涉及 | ❌ 不需要（Worker 内处理） |
| **单顶点重启（持久化）** | ❌ 不支持 | ✅ 需要 |
| **中断恢复继续执行** | ❌ 不支持 | ✅ 需要 |

---

## 如果要支持完整的 Pregel 重启

需要在 Pregel 层增加 Checkpoint：

```erlang
-record(pregel_checkpoint, {
    %% 执行标识
    execution_id :: binary(),

    %% 超步信息
    superstep :: non_neg_integer(),

    %% 所有顶点状态
    vertices :: #{vertex_id() => vertex()},

    %% 待处理消息
    inbox :: #{vertex_id() => [term()]},

    %% 待投递消息
    pending_messages :: [{vertex_id(), term()}],

    %% 顶点执行状态（用于单顶点重启）
    vertex_status :: #{vertex_id() => pending | completed | failed},

    %% 时间戳
    timestamp :: integer()
}).
```

---

## 建议实现路径

```
┌─────────────────────────────────────────────────────────────────┐
│                      实现优先级                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 【当前】Graph 层 Checkpoint                                  │
│     - 会话恢复                                                   │
│     - 历史查询                                                   │
│     - 简单场景足够                                               │
│                                                                 │
│  2. 【建议】Worker 内单顶点重试                                   │
│     - 添加 try-catch 和 superstep_state                        │
│     - 无需持久化                                                 │
│     - 参考: pregel_single_vertex_restart.md                    │
│                                                                 │
│  3. 【可选】Pregel 层 Checkpoint                                 │
│     - 长时间执行的中断恢复                                       │
│     - 持久化单顶点重启                                           │
│     - 根据实际需求决定是否实现                                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 两层 Checkpoint 协作

```
┌─────────────────────────────────────────────────────────────────┐
│                   两层 Checkpoint 协作模型                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Graph 层                              │   │
│  │                                                          │   │
│  │  checkpoint = #{                                        │   │
│  │    messages, context, result, metadata                  │   │
│  │  }                                                       │   │
│  │                                                          │   │
│  │  职责: 业务状态持久化                                     │   │
│  │  时机: 执行完成后                                         │   │
│  │  用途: 会话恢复、历史查询                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              │ 可选调用                         │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Pregel 层（可选）                       │   │
│  │                                                          │   │
│  │  checkpoint = #{                                        │   │
│  │    superstep, vertices, inbox, pending_messages,        │   │
│  │    vertex_status                                        │   │
│  │  }                                                       │   │
│  │                                                          │   │
│  │  职责: 执行状态持久化                                     │   │
│  │  时机: 每 N 个超步                                        │   │
│  │  用途: 中断恢复、单顶点重启                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
