# Pregel 消息可靠性与 pending_messages 分析

## 背景

根据之前的设计文档，`superstep_state` 应该存储在 Worker 中用于追踪顶点执行状态。本文档分析当前 `pending_messages` 机制的问题和改进方案。

---

## 问题 1：pending_messages 是否有必要？

### 当前实现

```erlang
%% pregel_master.erl:93
pending_messages :: #{non_neg_integer() => [{term(), term()}]}
%%                    ↑ WorkerId            ↑ 消息列表 [{VertexId, Value}]
```

```erlang
%% pregel_master.erl:386-400
handle_route_messages(TargetWorkerId, Messages, State) ->
    case maps:get(TargetWorkerId, Workers, undefined) of
        undefined ->
            %% Worker 不存在，缓存到 Master
            Existing = maps:get(TargetWorkerId, Pending, []),
            State#state{pending_messages = Pending#{TargetWorkerId => Messages ++ Existing}};
        Pid ->
            %% 直接发送
            pregel_worker:receive_messages(Pid, Messages),
            State
    end.
```

### 分析结论

**当前 `pending_messages` 的定位模糊，存在以下问题：**

| 问题 | 说明 |
|------|------|
| **职责不清** | 既处理 Worker 不存在的情况，又处理消息路由 |
| **设计冗余** | 如果 Worker 正常启动，不应该出现 "Worker 不存在" 的情况 |
| **与 BSP 模型冲突** | BSP 模型中，超步内的消息应在超步结束时统一投递，而不是实时发送 |

### 建议

**重新定义 `pending_messages` 的职责：**

```
┌─────────────────────────────────────────────────────────────────┐
│                 pending_messages 职责重定义                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  当前定位（问题）:                                                │
│  • 缓存发往不存在 Worker 的消息                                   │
│  • 这种情况不应该发生！Worker 应该在超步开始前全部就绪             │
│                                                                 │
│  建议定位:                                                        │
│  • 完全移除 Master 的 pending_messages                           │
│  • 消息缓存改为在发送方 Worker 的 outbox 中                       │
│  • 超步结束时，Worker 上报 outbox 给 Master                       │
│  • Master 统一路由到目标 Worker 的 inbox                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 问题 2：跨机器情况下 cast 丢消息

### 当前代码

```erlang
%% pregel_worker.erl - route_messages (简化)
route_messages(Messages, WorkerPids, NumWorkers) ->
    GroupedMessages = group_by_worker(Messages, NumWorkers),
    maps:foreach(
        fun(WorkerId, Msgs) ->
            case maps:get(WorkerId, WorkerPids, undefined) of
                undefined ->
                    gen_server:cast(Master, {route_messages, WorkerId, Msgs});
                Pid ->
                    gen_server:cast(Pid, {receive_messages, Msgs})  %% ⚠️ cast 可能丢失
            end
        end,
        GroupedMessages
    ).
```

### 问题分析

```
┌─────────────────────────────────────────────────────────────────┐
│              gen_server:cast 的可靠性问题                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  本地进程:                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  gen_server:cast(Pid, Msg)                              │   │
│  │  • 消息放入目标进程的邮箱                                 │   │
│  │  • 如果进程存在 → ✅ 可靠                                │   │
│  │  • 如果进程已死 → ❌ 静默丢弃                            │   │
│  │  • 没有返回值，调用方不知道是否成功                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  远程进程:                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  gen_server:cast({Name, Node}, Msg)                     │   │
│  │  • 依赖 Erlang 分布式协议                                │   │
│  │  • 网络分区 → ❌ 消息丢失                                │   │
│  │  • 节点不可达 → ❌ 消息丢失                              │   │
│  │  • 消息顺序不保证（跨节点）                              │   │
│  │  • 没有 ACK 机制                                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 问题 3：进程不存在时消息保存位置

### 三种场景分析

---

### 场景 1：所有 Worker 在本地

```
┌─────────────────────────────────────────────────────────────────┐
│                    场景 1：本地 Worker                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Node A (本地机器)                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Master Process                                          │   │
│  │  ┌─────────────┐                                        │   │
│  │  │ pending_msgs│ ← 不需要（Worker 都在本地，总是存在）   │   │
│  │  └─────────────┘                                        │   │
│  │                                                          │   │
│  │  Worker 0        Worker 1        Worker 2               │   │
│  │  ┌────────┐     ┌────────┐     ┌────────┐              │   │
│  │  │vertices│     │vertices│     │vertices│              │   │
│  │  │inbox   │     │inbox   │     │inbox   │              │   │
│  │  │outbox  │ ←── │outbox  │ ←── │outbox  │              │   │
│  │  └────────┘     └────────┘     └────────┘              │   │
│  │       ↑              ↑              ↑                   │   │
│  │       └──────────────┴──────────────┘                   │   │
│  │              本地进程间通信（可靠）                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  消息保存策略:                                                   │
│  • 消息保存在发送方 Worker 的 outbox 中                         │
│  • 超步结束时统一路由（BSP 模型）                                │
│  • 不需要 Master 的 pending_messages                            │
│                                                                 │
│  优点:                                                          │
│  ✅ 简单可靠                                                    │
│  ✅ 进程间通信保证送达                                          │
│  ✅ 无网络延迟                                                   │
│                                                                 │
│  风险:                                                          │
│  ⚠️ Worker 崩溃 → outbox 丢失                                   │
│  ⚠️ 需要 superstep_state 支持重试                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**本地场景建议：**
- 消息保存在 Worker 的 `outbox` 中
- Master 的 `pending_messages` 可以移除
- 通过 `superstep_state` 支持 Worker 内重试

---

### 场景 2：所有 Worker 在远程机器

```
┌─────────────────────────────────────────────────────────────────┐
│                    场景 2：远程 Worker                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Node A (Master)          Node B           Node C               │
│  ┌───────────────┐   ┌─────────────┐   ┌─────────────┐         │
│  │    Master     │   │  Worker 0   │   │  Worker 1   │         │
│  │               │   │  ┌───────┐  │   │  ┌───────┐  │         │
│  │               │   │  │outbox │  │   │  │outbox │  │         │
│  │               │   │  └───────┘  │   │  └───────┘  │         │
│  └───────────────┘   └─────────────┘   └─────────────┘         │
│         │                   │                 │                 │
│         │      ┌────────────┴─────────────────┤                 │
│         │      │         网络通信              │                 │
│         │      │     ⚠️ 可能丢失/延迟          │                 │
│         │      │                              │                 │
│                                                                 │
│  问题:                                                          │
│  ❌ cast 消息可能丢失（网络分区、节点崩溃）                       │
│  ❌ 没有 ACK 确认                                               │
│  ❌ Worker 崩溃后 outbox 丢失                                   │
│                                                                 │
│  消息保存策略选项:                                               │
│                                                                 │
│  Option A: 保存在发送方 Worker                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Worker 0 (Node B)                                      │   │
│  │  outbox = [{worker_1, msg1}, {worker_1, msg2}]         │   │
│  │  • 超步结束时发送                                        │   │
│  │  • 等待 ACK 或使用 call                                 │   │
│  │  • 超时重试                                              │   │
│  │  • Worker 崩溃 → 消息丢失（需要持久化）                   │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Option B: 保存在 Master                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Master (Node A)                                        │   │
│  │  pending_messages = #{                                  │   │
│  │    1 => [{v1, msg1}, {v2, msg2}]                       │   │
│  │  }                                                      │   │
│  │  • Worker 上报 outbox 给 Master                        │   │
│  │  • Master 统一路由                                      │   │
│  │  • Master 负责可靠投递                                  │   │
│  │  • Master 崩溃 → 需要持久化                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Option C: 持久化存储（最可靠）                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  外部存储 (Redis/DB/Mnesia)                             │   │
│  │  • Worker 写入消息到持久化存储                          │   │
│  │  • 目标 Worker 从存储读取                               │   │
│  │  • 支持崩溃恢复                                         │   │
│  │  • 增加延迟和复杂度                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**远程场景建议：**
- 使用 Option B（Master 集中管理）或 Option C（持久化存储）
- `cast` 改为 `call` 或增加 ACK 机制
- 考虑消息持久化

---

### 场景 3：混合部署（部分本地，部分远程）

```
┌─────────────────────────────────────────────────────────────────┐
│                    场景 3：混合部署                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Node A (Master + Worker 0)           Node B (Worker 1, 2)     │
│  ┌───────────────────────────┐       ┌───────────────────────┐ │
│  │  Master    Worker 0       │       │  Worker 1   Worker 2  │ │
│  │  ┌─────┐  ┌─────────┐    │       │  ┌───────┐  ┌───────┐ │ │
│  │  │     │  │ outbox  │    │       │  │outbox │  │outbox │ │ │
│  │  │     │  └─────────┘    │       │  └───────┘  └───────┘ │ │
│  │  └─────┘       │         │       │      │          │     │ │
│  └────────────────│─────────┘       └──────│──────────│─────┘ │
│                   │                        │          │       │
│         ┌─────────┴────────────────────────┴──────────┘       │
│         │                                                      │
│         │  消息路由复杂性:                                      │
│         │  • 本地 Worker 间 → 进程间通信（可靠）                │
│         │  • 远程 Worker 间 → 网络通信（不可靠）                │
│         │  • 跨本地/远程 → 需要区分处理                        │
│         │                                                      │
│                                                                 │
│  建议策略:                                                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  统一使用 Master 路由模式                                │   │
│  │                                                          │   │
│  │  1. 所有 Worker 的 outbox 上报给 Master                 │   │
│  │  2. Master 判断目标 Worker 位置:                        │   │
│  │     • 本地 → 直接投递（call/cast 都可）                 │   │
│  │     • 远程 → 可靠投递（call + 重试 或 持久化）          │   │
│  │  3. Master 记录投递状态，支持重试                       │   │
│  │                                                          │   │
│  │  优点:                                                   │   │
│  │  ✅ Worker 无需关心目标位置                             │   │
│  │  ✅ 统一的可靠性保证                                    │   │
│  │  ✅ 便于监控和调试                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 综合建议

### 架构重构方案

```
┌─────────────────────────────────────────────────────────────────┐
│                    建议的消息路由架构                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  超步执行阶段:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Worker 执行顶点计算                                     │   │
│  │  • 计算结果保存在 superstep_state                        │   │
│  │  • 发出的消息保存在 Worker 的 outbox                     │   │
│  │  • 不实时发送消息（BSP 模型）                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  超步完成阶段:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Worker 上报 Master                                      │   │
│  │  • 汇总结果（active_count, failed_vertices 等）          │   │
│  │  • outbox 内容（待路由的消息）                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  消息路由阶段:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Master 统一路由                                         │   │
│  │  • 收集所有 Worker 的 outbox                            │   │
│  │  • 按目标 Worker 分组                                    │   │
│  │  • 可靠投递到各 Worker 的 inbox                         │   │
│  │  • 记录投递状态，支持重试                                │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  下一超步开始:                                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Worker 从 inbox 获取消息                                │   │
│  │  • Master 已确保消息送达                                 │   │
│  │  • Worker 不需要关心消息来源                             │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 核心改动

| 组件 | 当前实现 | 建议改动 |
|------|----------|----------|
| **Worker outbox** | 实时发送消息 | 缓存到超步结束 |
| **Master pending_messages** | 缓存无法投递的消息 | 改为集中路由所有消息 |
| **消息投递** | cast（不可靠） | call + 重试（可靠） |
| **Worker inbox** | 实时接收 | 超步开始时批量接收 |

### 数据结构调整

```erlang
%% Worker State 扩展
-record(worker_state, {
    ...
    %% 执行状态追踪
    superstep_state :: superstep_state(),

    %% 当前超步的输出消息（不实时发送）
    outbox :: [{vertex_id(), term()}]
}).

%% Master State 调整
-record(master_state, {
    ...
    %% 移除 pending_messages（不再需要）
    %% pending_messages :: removed,

    %% 新增：待路由的消息（从 Worker 收集）
    routing_queue :: #{worker_id() => [{vertex_id(), term()}]}
}).
```

---

## 可靠性级别选择

```
┌─────────────────────────────────────────────────────────────────┐
│                     可靠性级别选择                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Level 0: 当前实现（本地单机）                                   │
│  ─────────────────────────────                                  │
│  • cast 消息投递                                                │
│  • 进程崩溃 → 消息丢失                                          │
│  • 适用：开发测试、单机场景                                     │
│                                                                 │
│  Level 1: call + 重试（推荐）                                   │
│  ──────────────────────────                                    │
│  • call 消息投递，有 ACK                                        │
│  • 超时重试（指数退避）                                         │
│  • Worker 崩溃 → 消息丢失                                       │
│  • 适用：生产单机、小规模分布式                                 │
│                                                                 │
│  Level 2: 持久化消息队列                                        │
│  ────────────────────────                                      │
│  • 消息持久化到外部存储                                         │
│  • 支持 Worker 崩溃恢复                                         │
│  • 适用：大规模分布式、高可靠性要求                             │
│                                                                 │
│  Level 3: 完整 Checkpoint                                       │
│  ─────────────────────────                                     │
│  • superstep_state + outbox 持久化                              │
│  • 支持任意崩溃恢复                                             │
│  • 适用：关键业务、长时间运行任务                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 结论

| 问题 | 回答 |
|------|------|
| **pending_messages 是否有必要？** | 当前设计不合理，需要重新定位为 "集中路由队列" |
| **cast 跨机器丢消息？** | 是的，需要改为 call + 重试 或 持久化 |
| **消息保存位置？** | 建议：Worker 的 outbox → Master 集中路由 → Worker 的 inbox |

---

## 相关文档

- `pregel_superstep_state_structure.md` - superstep_state 数据结构
- `pregel_superstep_state_location.md` - superstep_state 存储位置
- `pregel_pending_writes_analysis.md` - pending_writes 需求分析
- `pregel_pending_writes_placement.md` - pending_writes 放置分析
