# Pregel Vertex Value 与 GraphState 同步机制

## 问题

Worker 间的 `vertex.value`（GraphState）是否同步？

**答案：不同步，但这是设计如此，不是问题。**

## 当前存储结构

```
┌─────────────────────────────────────────────────────────────────┐
│  Worker 0                         Worker 1                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  vertices = #{                    vertices = #{                 │
│    __start__ => #{                  llm_call => #{              │
│      value => #{                      value => #{               │
│        result => {ok, State0}           result => {ok, State1}  │
│      }                                }                         │
│    },                               },                          │
│    __end__ => #{                    execute_tools => #{         │
│      value => #{                      value => #{               │
│        result => undefined              result => {ok, State2}  │
│      }                                }                         │
│    }                                }                           │
│  }                                }                             │
│                                                                 │
│  State0 ≠ State1 ≠ State2  ← 确实不同步！                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 为什么不是问题？

### 状态通过消息传递，不是通过存储同步

```
执行流程:

超级步 0:
┌─────────────┐
│  __start__  │ ─── 发送 {state, S0} ───→ llm_call 的 inbox
│  result=S0  │
└─────────────┘

超级步 1:
                    ┌─────────────┐
llm_call 收到 S0 ──→│  llm_call   │ ─── 发送 {state, S1} ───→ execute_tools 的 inbox
                    │  result=S1  │
                    └─────────────┘

超级步 2:
                                        ┌────────────────┐
execute_tools 收到 S1 ─────────────────→│ execute_tools  │ ─── 发送 {state, S2} ───→
                                        │   result=S2    │
                                        └────────────────┘
```

### 关键理解

| 概念 | 说明 |
|------|------|
| **vertex.value.result** | 该顶点执行后的**历史快照** |
| **消息中的 state** | **当前流动的权威状态** |
| **同步方式** | 通过消息传递，不是存储同步 |

## vertex_value 结构

代码位置：`graph_compute.erl:31-37`

```erlang
-type vertex_value() :: #{
    node := graph_node:graph_node(),     %% 节点定义（静态）
    edges := [graph_edge:edge()],        %% 出边定义（静态）
    result := undefined | {ok, state()} | {error, term()},  %% 执行结果快照
    initial_state => graph_state:state(),%% 仅 __start__ 有
    activated => boolean()               %% 仅 __start__ 有
}.
```

**result 是执行结果的快照，不是全局同步的状态！**

## 状态流动模型

```
┌─────────────────────────────────────────────────────────────────┐
│                    状态流动模型                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  权威状态在"消息"中流动，不在"存储"中同步                          │
│                                                                 │
│  时间 ──────────────────────────────────────────────────────→  │
│                                                                 │
│  超级步 0     超级步 1        超级步 2        超级步 3           │
│                                                                 │
│  __start__    llm_call       execute_tools   __end__           │
│     │            │                │             │               │
│     │ S0         │ S1             │ S2          │ S3            │
│     ▼            ▼                ▼             ▼               │
│  ┌─────┐      ┌─────┐          ┌─────┐      ┌─────┐            │
│  │ S0  │ ───→ │ S1  │ ───────→ │ S2  │ ───→ │ S3  │            │
│  └─────┘      └─────┘          └─────┘      └─────┘            │
│    ↑            ↑                ↑             ↑               │
│  消息传递     消息传递         消息传递      最终结果            │
│                                                                 │
│  各节点的 result 只是该时刻的快照，不需要同步                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 与传统共享状态模型对比

```
传统模型（需要同步）:
─────────────────────
┌─────────┐
│ 全局    │ ←── 所有节点读写同一个状态
│ State   │ ←── 需要锁、事务等同步机制
└─────────┘
    ↑↓
┌───┴───┐
│ │ │ │ │
N1 N2 N3 N4


Pregel 模型（消息传递）:
────────────────────────
N1 ──S0──→ N2 ──S1──→ N3 ──S2──→ N4

状态通过消息流动
每个节点只处理收到的消息
不需要全局同步
```

## Worker 间 vertex.value 不同步会有问题吗？

**不会！** 因为：

| 场景 | 说明 |
|------|------|
| **执行时** | 节点从消息中获取状态，不从其他节点的 value 读取 |
| **最终结果** | 从 `__end__` 节点的 result 获取 |
| **历史追踪** | 各节点的 result 可用于调试/审计，但不影响执行 |

## 最终结果如何获取？

代码位置：`graph_compute.erl:92-101`

```erlang
%% 执行完成后，从 __end__ 顶点提取结果
Graph = pregel:get_result_graph(Result),
Status = pregel:get_result_status(Result),

%% 优先从 __end__ 顶点提取结果
EndResult = case pregel:get_graph_vertex(Graph, ?END_NODE) of
    {error, _} ->
        undefined;
    {ok, EndVertex} ->
        EndValue = pregel_vertex:value(EndVertex),
        maps:get(result, EndValue, undefined)
end.
```

最终结果从 `__end__` 节点的 `result` 字段获取，这是最后一个执行节点写入的状态。

## 执行完成后的图状态

```
执行完成后:

┌─────────────────────────────────────────────────────────────────┐
│  Worker 0                         Worker 1                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  __start__.result = {ok, S0}      llm_call.result = {ok, S1}   │
│       ↓                                ↓                        │
│    初始状态                          LLM 处理后                  │
│                                                                 │
│  __end__.result = {ok, S3}        execute_tools.result={ok,S2} │
│       ↓                                ↓                        │
│    最终结果 ✅                       工具执行后                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

提取最终结果: __end__.result = {ok, S3}
```

## 总结

| 问题 | 回答 |
|------|------|
| **Worker 间 GraphState 同步吗？** | ❌ 不同步 |
| **这是问题吗？** | ❌ 不是，这是 Pregel 设计 |
| **状态如何传递？** | 通过消息 `{state, GraphState}` |
| **最终结果从哪获取？** | `__end__` 节点的 `result` |
| **各节点 result 的作用** | 历史快照，用于调试/审计 |

## 核心设计原则

```
┌─────────────────────────────────────────────────────────────────┐
│                      Pregel 状态管理原则                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 状态通过消息传递，不通过共享存储                              │
│                                                                 │
│  2. 每个节点只关心收到的消息，不关心其他节点的存储状态             │
│                                                                 │
│  3. vertex.value.result 是执行快照，不是同步状态                 │
│                                                                 │
│  4. 最终结果从终止节点 (__end__) 获取                            │
│                                                                 │
│  5. 这种设计避免了分布式锁、事务等复杂同步机制                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
